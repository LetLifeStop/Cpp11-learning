C++11 知识整理

1. 对class的理解   

答：首先，class 也是一种数据类型，只不过是可以由开发者自由定义的一种数据类型；可以用来封装成员变量和成员函数；支持抽象，继承，多态性；在定义数据类型的时候，private，public，也从一定程度上保证了数据的安全性

抽象性：含有纯虚函数的类被称为抽象类，用途是为派生类提供基类

多态性：对于不同对象接受相同信息时产生不同的动作。体现在两个方面，一是在编译的时候，函数重载是一个方面；二是在运行的时候，虚函数是一个方面

继承性：子类具有父类的各种属性和方法，而不必再次编写相同的代码

2. 什么是类

答：一种将抽象转换成用于定义的类型的工具，将数据表示方法和操纵这些数据的方法组合一起整合成一个包

3. 如何将私有成员变量取出

答：方法1：通过public中的函数，传出参数将私有成员变量取出。方法2：友元函数

4. *this 指针

答：经典回答，进入一个房间，能看见房间里的东西，但是整个房间看不到了，然后this指针就是时刻盯着这整个房间。this指针是类的一个自动生成，自动隐藏的私有成员。存在于类的非静态成员函数中，指向内调用函数所在的对象。全局仅有一个this指针，当一个对象被创建的时候，this指针就存放指向对象数据的首地址

5. 类和对象的区别和联系

答：区别：（1）.定义不同 ，类是现实世界或思维世界的实体在计算机的反映，他将数据以及对数据的操作封装在了一起。对象是有具体类型的变量

（2） 范畴不同，类是一个抽象的概念。对象是类的一个具体，是真是存在的东西

（3）状态不同，类是一个静态的概念，当没有为了创建任何数据的时候，类本身不存在于内存空间中

 联系：类是对象的抽象，而对象是类的具体事例 。鞋是同一个类，白鞋，黑鞋，，这些是对象

6. 值拷贝&&内容拷贝  浅拷贝&&深拷贝

答：浅拷贝对应于值拷贝，深拷贝对应于内容拷贝。浅拷贝是两个对象操作同一块内存，而深拷贝是先创建相同大小的内存，然后将内容拷贝过来；

7. 拷贝构造函数和赋值函数的区别：

答：从概念上来说，第一个是构造函数，第二个是赋值函数；从使用场景来说，第一个一般用于初始化各种参数，第二个是要求 = 两边均存在

8. 类中析构函数和构造函数调用顺序：

答：析构函数，是先调用派生类的析构函数，然后再调用基类的析构函数；而构造函数正好相反

9. 虚函数，纯虚函数

答：虚函数，在基类中的某一个成员函数前面加上virtual关键词，提供了一种接口界面，允许在派生类中对基类的虚函数进行重新定义，这就是多态性很好地一个体现。当在基类中把成员函数定义为虚函数的时候，如果要在派生类中调用这个虚函数，参数类型，顺序，个数都必须相同，但是对数据的操作是可以变化的。

纯虚函数：在基类中仅仅给出声明，不对虚函数实现定义，实现定义是在派生类中实现的。 含有纯虚函数的类被称为抽象类，继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那个这个派生类也是抽象类。

10. =default 和  =delete

答：这种行为只是对构造，赋值，析构这三类特殊的函数设计的，=default是为了让编译器合成默认的构造函数。=delete是为了不想让编译器合成某些函数

11. explicit关键词

答：在类的构造函数中，如果只是对一个参数（>=2时不行）的构造函数，如果要防止类构造函数的隐式自动转换，可以在该构造函数前面加上explicit关键词，就可以避免这个。

12. new/delete , new[]/del[]

答：开空间的时候实质上还是通过malloc实现的，new用于单个对象或者实例的创建，在申请单个类型变量的时候可以进行初始化，delete和new配套使用。new []是多个对象或者实例以数组的形式来进行创建的，每个对象都会调用构造函数；delete[]调用的时候，一次调用对象数组中每个对象的析构函数，然后再将内存释放掉

13. new和malloc区别

答：malloc只是动态分配内存，而new除了动态分配内存还会调用构造函数来对创建出的对象或者实例进行初始化

14. 重载new 和 delete操作符的好处

答：通过重载new 和 delete 操作符，我们可以做一些内存管理工作。比如果加一个计数器，在new的时候就计数加1， delte的时候就-1 ，这样最终执行完程序的时候，统计这个计数器是否为0，如果不为0就证明有的对象没有被delete，这就有可能到这内存泄漏

15. vector的底层实现

答：当我们担心空间不够而开很大的数组的时候，vector可以很好地优化这一点。vector在定义的时候会先申请一个空间，当占用的这个空间到达一定比例的时候，vector会自动向内存中申请一段空间，然后把原来的数据迁移到这个新申请的空间中，然后释放掉原有的空间，但是重新分配空间是一个很耗时的操作，而vector对此进行了许多优化。注意：当扩容的时候，vector会进行内存的一个重新分配，和vexctor有关的迭代器就会失效

16. allocator 的作用

答：分配内存；构造对应的对象，析构函数；释放内存

17. 智能指针类

答：shared_ptr , 共享式指针管理类。内部有一个引用计数，每当有一个新的shared_ptr指针指向同一个被管理的内存资源的时候，计数器会加一，当计数器为0的时候，这个内存资源会被释放。

​      unique_ptr，独占式指针管理类。 当unique_ptr指针所指向的对象被销毁/重置的时候，这个内存资源会被释放。当一个unique_ptr指针赋给另一个unique_ptr指针的时候，内存资源的管理从源对象转移到目标对象

18. initializer_list

答：initializer_list，可以用来初始化列表语法将STL容器初始化为一系列值。（处理长度不同的列表），注意，initializer_list的迭代器类型为cons，所以不能修改initializer_list中的值

19. const  和 constexpr 

答：cosnt代表对变量的一个修饰，告诉编译器这个变量被初始化，并且不能直接修改

，既可以在编译的时候指定，也可以在运行的时候指定；constexpr可以用来修改变量，函数，构造函数。（看成编译时就能得出常量值得表达式），相对于宏来说，没有额外的开销，并且更加安全可靠；在编译器对constexpr的代码进行非常大的优化，比如将constexpr 表达式都直接替换成最终结果

20. static_assert 

答：static_assert(bool_constexpr ,message);当bool_constexpr返回false的时候，编译器将报错，报错的内容是message

21. 引用和指针

答：引用就是某个变量的别名。引用和指针在做参数及做返回值类型上几乎效率相同，远远高于传值。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量的一个别名，引用本身不占存储单元。

不同点：1. 引用在定义的时候必须初始化，指针没有要求。2. 引用只能初始化用一个实体，而指针可以在任何时候指向任何一个同类型实体 3. 没有NULL引用，但是有NULL指针。4. 在sizeof中，引用的结果为引用类型的大小，而指针始终是地址空间所占自己个数 5. 引用自加即引用的实体+1，而指针自加是指针往后偏移一个类型的大小  6. 引用使用起来比指针更加简洁，安全

22. 将 “引用”作为函数参数有哪些特点？

答：

* 首先 和 传递 指针的效果是一样的
* 使用引用传递函数的参数，在内存中并没有产生实参的副本，是直接对实参进行操作的；而如果使用一般变量传递函数的参数的话，会产生变量的副本，如果传递的参数的数据较大的时候，用引用比用一般变量传递参数的效率和所占的空间都好
* 代码更加清晰，易读

23. 在什么时候需要使用“常引用”？

答：如果既要利用引用提高程序的效率，又要保护传递给参数的数据不在函数中被改变

24. 将引用作为函数返回值类型的好处和需要遵守的规则？

* 好处：在内存中不会产生内存的副本

需要遵守的规则：

* 不能返回局部变量的引用，因为局部变量在函数返回的时候会被销毁，所以被返回的引用就会成了一个无用的引用
* 不能返回函数内部new分配的内存的引用。虽然不会有上一个情况的发生，但如果被函数返回的引用只是一个临时变量，那么这段空间就不会被释放

25. struct 与 union 的区别：

答：1. struct 和 union 都是有多个不同的数据类型成员构成的，但是在任意一个时刻，union中只存一个被选中的一个成员，而struct的所有成员都存在，struct变量的总长度等于这个结构体内部所有成员的总和。而union中的成员不能同时存在，union变量的产固定 等于union中成员长度最长的那个

2. 对于union中不同成员赋值，将会对其他成员进行重写，原来的成员就会被覆盖，而struct不会

26. 重载 和 重写的区别？

答：从定义上说：重载是允许存在多个同名函数，而函数的参数有所区别，或者返回值；重写是子类重新定义父类虚函数的一个方法

从实现原理上说：

重载的调用，在编译期间就已经确定了，这是一个静态的，和多态并没有关系

重写的调用，当子类重新定义了父类的虚函数的时候，父类指针根据赋给她不同的子类指针，动态的调用属于子类的函数，在编译期间无法确定

27. 什么时候只能用 intialization list 而不能用 assignment ？

答：当类中函数const，reference（引用）成员变量 ； 基类的构造函数需要初始化表

28.  描述内存分配方式以及他们的区别？

答：从静态存储区分配，在编译的时候就已经分配好，如全局变量，static变量；

从栈分配，在执行函数的时候，函数内部局部变量的申请都可以在栈上申请空间，当函数执行完后这部分内存自动释放。

从堆上分配，动态分配。当运行malloc 或者new 的时候，会在这上面申请

29. const 和 define 相比的优点？

答：const 的作用，定义常量，修饰函数参数，修饰函数返回值。通过const修饰的东西会受到强制保护，可以预防意外的变动，提高程序的健壮性

const常量有数据类型，而define没有。在编译的时候，编译器可以对前者的进行一个检查

30. 数组与指针的区别？

答：1）数组可以在编译的时候被创建，如全局数组，或者在栈上被创建。指针可以随时指向任意类型的内存块  2）sizeof可以计算出数组的大小，而sizeof对指针来说，只是当前指针变量的字节数

31. 基类的析构函数不是虚函数，会带来什么问题？

答：派生类的析构函数用不上，造成资源的泄漏

32. 全局变量和局部变量的区别？

答：生命周期不同：

全局变量随着主程序的运行而创建，局部变量是在函数内部申请的，当函数返回的时候，这个变量就会被销毁

使用方式：

全局变量在函数的各个部分都能使用，而局部变量只能在局部使用

通过内存分配的方式来判断，全局变量在主程序运行的时候，分配在全局数据段。局部变量是在堆栈中

33. static关键词

答：函数或代码块中的变量在函数或者代码块第一次初始化分配内存的时候，就算函数或者代码块执行完毕，这个变量也不会回收，知道程序结束才会被回收

不可重入性；记忆性；