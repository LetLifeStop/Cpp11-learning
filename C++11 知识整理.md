C++11 知识整理

1. 对class的理解   

答：首先，class 也是一种数据类型，只不过是可以由开发者自由定义的一种数据类型；可以用来封装成员变量和成员函数；支持抽象，继承，多态性；在定义数据类型的时候，private，public，也从一定程度上保证了数据的安全性

抽象性：含有纯虚函数的类被称为抽象类，用途是为派生类提供基类

多态性：对于不同对象接受相同信息时产生不同的动作。体现在两个方面，一是在编译的时候，函数重载是一个方面；二是在运行的时候，虚函数是一个方面

继承性：子类具有父类的各种属性和方法，而不必再次编写相同的代码

2. 什么是类

答：一种将抽象转换成用于定义的类型的工具，将数据表示方法和操纵这些数据的方法组合一起整合成一个包

3. 如何将私有成员变量取出

答：方法1：通过public中的函数，传出参数将私有成员变量取出。方法2：友元函数

4. *this 指针

答：经典回答，进入一个房间，能看见房间里的东西，但是整个房间看不到了，然后this指针就是时刻盯着这整个房间。this指针是类的一个自动生成，自动隐藏的私有成员。存在于类的非静态成员函数中，指向内调用函数所在的对象。全局仅有一个this指针，当一个对象被创建的时候，this指针就存放指向对象数据的首地址

5. 类和对象的区别和联系

答：区别：（1）.定义不同 ，类是现实世界或思维世界的实体在计算机的反映，他将数据以及对数据的操作封装在了一起。对象是有具体类型的变量

（2） 范畴不同，类是一个抽象的概念。对象是类的一个具体，是真是存在的东西

（3）状态不同，类是一个静态的概念，当没有为类创建任何数据的时候，类本身不存在于内存空间中

 联系：类是对象的抽象，而对象是类的具体事例 。鞋是同一个类，白鞋，黑鞋，，这些是对象

6. 值拷贝&&内容拷贝  浅拷贝&&深拷贝

答：浅拷贝对应于值拷贝，深拷贝对应于内容拷贝。浅拷贝是两个对象操作同一块内存，而深拷贝是先创建相同大小的内存，然后将内容拷贝过来；

7. 拷贝构造函数和赋值函数的区别：

答：从概念上来说，第一个是构造函数，第二个是赋值函数；从使用场景来说，第一个一般用于初始化各种参数，第二个是要求 = 两边均存在

8. 类中析构函数和构造函数调用顺序：

答：析构函数，是先调用派生类的析构函数，然后再调用基类的析构函数；而构造函数正好相反

9. 虚函数，纯虚函数

答：虚函数，在基类中的某一个成员函数前面加上virtual关键词，提供了一种接口界面，允许在派生类中对基类的虚函数进行重新定义，这就是多态性很好地一个体现。当在基类中把成员函数定义为虚函数的时候，如果要在派生类中调用这个虚函数，参数类型，顺序，个数都必须相同，但是对数据的操作是可以变化的。

纯虚函数：含有纯虚函数的类不能被声明对象，在基类中仅仅给出声明，不对虚函数实现定义，实现定义是在派生类中实现的。 含有纯虚函数的类被称为抽象类，继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那个这个派生类也是抽象类。

10. =default 和  =delete

答：这种行为只是对构造，赋值，析构这三类特殊的函数设计的，=default是为了让编译器合成默认的构造函数。=delete是为了不想让编译器合成某些函数

11. explicit关键词

答：在类的构造函数中，如果只是对一个参数（>=2时不行）的构造函数，如果要防止类构造函数的隐式自动转换，可以在该构造函数前面加上explicit关键词，就可以避免这个。

12. new/delete , new[]/del[]

答：开空间的时候实质上还是通过malloc实现的，new用于单个对象或者实例的创建，在申请单个类型变量的时候可以进行初始化，delete和new配套使用。new []是多个对象或者实例以数组的形式来进行创建的，每个对象都会调用构造函数；delete[]调用的时候，一次调用对象数组中每个对象的析构函数，然后再将内存释放掉

13. new和malloc区别

答：1）malloc只是动态分配内存，而new除了动态分配内存还会调用构造函数来对创建出的对象或者实例进行初始化。  2）new是从自由存储区为对象动态分配内存空间，而malloc是从堆上动态分配内存    3）返回类型不同，new返回的是对象类型的指针，不需要进行强制的类型转换。而malloc是返回的泛型指针，需要进行强制的类型转换  4）内存分配失败时的返回值，new抛出异常，而malloc会返回NULL   5）new不需要指定大小，会根据类型信息自动计算，而malloc需要指定大小 6）当分配内存的时候，new 能通过指定处理函数或者重新指定分配器，而malloc无法通过用户代码处理 7）new允许函数重载，malloc不允许函数重载

14. 重载new 和 delete操作符的好处

答：通过重载new 和 delete 操作符，我们可以做一些内存管理工作。比如果加一个计数器，在new的时候就计数加1， delte的时候就-1 ，这样最终执行完程序的时候，统计这个计数器是否为0，如果不为0就证明有的对象没有被delete，这就有可能到这内存泄漏

15. vector的底层实现

答：当我们担心空间不够而开很大的数组的时候，vector可以很好地优化这一点。vector在定义的时候会先申请一个空间，当占用的这个空间到达一定比例的时候，vector会自动向内存中申请一段空间，然后把原来的数据迁移到这个新申请的空间中，然后释放掉原有的空间，但是重新分配空间是一个很耗时的操作，而vector对此进行了许多优化。注意：当扩容的时候，vector会进行内存的一个重新分配，和vexctor有关的迭代器就会失效

16. allocator 的作用

答：分配内存；构造对应的对象，析构函数；释放内存

17. 智能指针类

答：

 智能指针的作用是管理一个指针，所以存在如下情况：申请空间忘记释放，会造成内存的泄漏，而智能指针可以在很大的程度上避免这个问题，因为智能指针就是一个类，当超出作用域的时候，会自动调用析构函数，析构函数会自动释放资源

   auto_ptr ，采用所有权模式

​     shared_ptr , 共享式指针管理类。内部有一个引用计数，每当有一个新的shared_ptr指针指向同一个被管理的内存资源的时候，计数器会加一，当计数器为0的时候，这个内存资源会被释放，当。

​      unique_ptr，独占式指针管理类。 当unique_ptr指针所指向的对象被销毁/重置的时候，这个内存资源会被释放。当一个unique_ptr指针赋给另一个unique_ptr指针的时候，内存资源的管理从源对象转移到目标对象

​     weak_ptr ，是不控制对象生命周期的智能指针，指向一个shared_ptr管理的对象，这个指针的构造和析构并不会引起计数的增加或者减少。可以用来解决shared_ptr造成的死锁问题

18. initializer_list

答：initializer_list，可以用来初始化列表语法将STL容器初始化为一系列值。（处理长度不同的列表），注意，initializer_list的迭代器类型为const，所以不能修改initializer_list中的值

19. const  和 constexpr 

答：cosnt代表对变量的一个修饰，告诉编译器这个变量被初始化，并且不能直接修改

，既可以在编译的时候指定，也可以在运行的时候指定；constexpr可以用来修改变量，函数，构造函数。（看成编译时就能得出常量值得表达式），相对于宏来说，没有额外的开销，并且更加安全可靠；在编译器对constexpr的代码进行非常大的优化，比如将constexpr 表达式都直接替换成最终结果

20. static_assert 

答：static_assert(bool_constexpr ,message);当bool_constexpr返回false的时候，编译器将报错，报错的内容是message

21. 引用和指针

答：引用就是某个变量的别名。引用和指针在做参数及做返回值类型上几乎效率相同，远远高于传值。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量的一个别名，引用本身不占存储单元。

不同点：1. 引用在定义的时候必须初始化，指针没有要求。2. 引用只能初始化用一个实体，而指针可以在任何时候指向任何一个同类型实体 3. 没有NULL引用，但是有NULL指针。4. 在sizeof中，引用的结果为引用类型的大小，而指针始终是地址空间自己所占的字节个数 5. 引用自加即引用的实体+1，而指针自加是指针往后偏移一个类型的大小  6. 引用使用起来比指针更加简洁，安全 7. 指针可以有多级指针，而引用只有一级

22. 将 “引用”作为函数参数有哪些特点？

答：

* 首先 和 传递 指针的效果是一样的
* 使用引用传递函数的参数，在内存中并没有产生实参的副本，是直接对实参进行操作的；而如果使用一般变量传递函数的参数的话，会产生变量的副本，如果传递的参数的数据较大的时候，用引用比用一般变量传递参数的效率和所占的空间都好
* 代码更加清晰，易读

23. 在什么时候需要使用“常引用”？

答：如果既要利用引用提高程序的效率，又要保护传递给参数的数据不在函数中被改变

24. 将引用作为函数返回值类型的好处和需要遵守的规则？

* 好处：在内存中不会产生内存的副本

需要遵守的规则：

* 不能返回局部变量的引用，因为局部变量在函数返回的时候会被销毁，所以被返回的引用就会成了一个无用的引用
* 不能返回函数内部new分配的内存的引用。虽然不会有上一个情况的发生，但如果被函数返回的引用只是一个临时变量，那么这段空间就不会被释放

25. struct 与 union 的区别：

答：1. struct 和 union 都是有多个不同的数据类型成员构成的，但是在任意一个时刻，union中只存一个被选中的一个成员，而struct的所有成员都存在，struct变量的总长度等于这个结构体内部所有成员的总和。而union中的成员不能同时存在，union变量的产固定 等于union中成员长度最长的那个

2. 对于union中不同成员赋值，将会对其他成员进行重写，原来的成员就会被覆盖，而struct不会

26. 重载 和 重写的区别？

答：从定义上说：重载是允许存在多个同名函数，而函数的参数有所区别，或者返回值；重写是子类重新定义父类虚函数的一个方法

从实现原理上说：

重载的调用，在编译期间就已经确定了，这是一个静态的，和多态并没有关系

重写的调用，当子类重新定义了父类的虚函数的时候，父类指针根据赋给她不同的子类指针，动态的调用属于子类的函数，在编译期间无法确定

27. 什么时候只能用 intialization list 而不能用 assignment ？

答：当类中函数const，reference（引用）成员变量 ；类的构造函数需要调用其基类的构造函数

28.  描述内存分配方式以及他们的区别？

答：从静态存储区分配，在编译的时候就已经分配好，如全局变量，static变量；

从栈分配，在执行函数的时候，函数内部局部变量的申请都可以在栈上申请空间，当函数执行完后这部分内存自动释放。

从堆上分配，动态分配。当运行malloc 或者new 的时候，会在这上面申请

29. const 和 define 相比的优点？

答：const 的作用，定义常量，修饰函数参数，修饰函数返回值。通过const修饰的东西会受到强制保护，可以预防意外的变动，提高程序的健壮性

const常量有数据类型，而define没有。在编译的时候，编译器可以对前者的进行一个检查

30. 数组与指针的区别？

答：1）赋值的时候，同类型的指针变量可以相互赋值，而数组不行，只能一个一个元素的赋值或者拷贝 2）sizeof可以计算出数组的大小，而sizeof对指针来说，只是当前指针变量的字节数 3）数组在内存中是连续存放的，而指针的存储空间不能确定  4）指针存储的是地址，数组存储的是数据 5）指针是间接访问数据，通过指针保存的地址来访问数据，数组是直接访问数据 

31. 基类的析构函数不是虚函数，会带来什么问题？

答：派生类的析构函数用不上，造成资源的泄漏

32. 全局变量和局部变量的区别？

答：生命周期不同：

全局变量随着主程序的运行而创建，局部变量是在函数内部申请的，当函数返回的时候，这个变量就会被销毁

使用方式：

全局变量在函数的各个部分都能使用，而局部变量只能在局部使用

通过内存分配的方式来判断，全局变量在主程序运行的时候，分配在全局数据段。局部变量是在堆栈中

33. static关键词

答：函数或代码块中的变量在函数或者代码块第一次初始化分配内存的时候，就算函数或者代码块执行完毕，这个变量也不会回收，知道程序结束才会被回收

不可重入性；记忆性；

34. c 和 c++ 区别

答：设计思想上，c++是面向对象的语言，c是面向过程的结构化编程

语法上，c++ 具有重载，继承，多态三种特性；c++相比c增加了许多类型安全的功能，比如强制的类型转换；c++ 支持范式编程，如模板类，函数模板等

35. static 关键字的作用

答：

1） 全局静态变量

* 存储在静态存储区中，在整个程序运行期间一直存在
* 自动初始化为0
* 全局静态变量在声明他的文件之外是不可见的

2）局部静态变量

* 存储在静态存储区中，作用域为局部作用域每当定义它的函数或者语句块结束的时候，作用域结束。但是这个变量并没有被销毁，仍然存在内存中，直到函数被再次调用

3）静态函数

* 在函数返回类型前面加static，函数就定义为静态函数，这个函数只能在本cpp内使用，不会同其他cpp中的同名函数起冲突

4）类的静态成员

* 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则性，也保证了安全性、对多个对象来说，静态成员数据只存储在一处，供所有的对象共用。

5）类的静态函数

* 静态成员函数和静态成员都属于类的静态成员，都不是对象成员。**在静态成员函数的实现中不能直接引用类中说明的非静态成员，但是可以引用类中说明的静态成员**，如果静态成员函数要引用非静态成员，可以通过对象来引用

36. 抽象和接口

答：抽象类，一个类中只要含有纯虚函数，那么它就是抽象类；接口，一个类中，没有定义任何成员变量，所有的成员函数都是公有的，不能有private修饰符，并且所有的成员函数都是共有并且都是纯虚函数

37. 进程和程序的主要区别

答：进程是程序的一次执行。具有动态性：是程序的一次执行；并发性：进程是可以并发执行 ；独立性：系统进行资源分配和调度的一个独立单位；异步性：进程间的相互制约，使得进程具有间隙；结构性：进程是具有结构的

区别：程序时永存的，进程是暂时的；程序是静态的观念，进程是动态的观念；进程具有并发性，而程序没有；进程和程序不是一一对应的，一个程序可以执行多个进程，一个进程可以执行一个或者多个程序

38. 类的静态成员和非静态成员有何区别？

答：非静态成员也叫成员变量  。1） 名称上的区别。成员变量也叫实例变量；静态宾亮也叫类变量  2）内存存储的区别，成员变量存储到堆内存中，静态变量存储在静态区中

3）声明周期不同，成员变量随着对象的出现而出现，随着对象的消失而消失；非成员变量随着类的创建而出现，随着类的消失而消失 

39. extern关键词

答：1）声明extern 关键字的全局变量和函数使得他们能够跨文件被访问  2）extern 是c/c++ 表明函数和全局变量作用范围的关键字，声明的函数和关键字可以在本模块使用或者其他模块使用 。**注意**，extren int c；这个语句，并没有对int申请空间，仅仅是声明一个变量    3） 在c++中引用C语言的函数和变量，通过extern "C"{  ----- }来实现 

40.  extern 和 static 的区别

答：1）作用范围不同，extern 是外部存储类型，属于全局变量是除了本编译单元可以使用，别的编译单元也可以使用这个变量；但是static是静态存储类型，只允许本编译单元使用这个变量

41. c++ 中的四种转换

答：1）static_case 静态转换，不可用于多态，静态类型的转换 ，如非const转const，void * 转指针  2）dynamic_cast，动态类型的转换，只能用于含有虚函数的类，用于类层次间的向上（子类向基类的转换）和向下转换，只能转指针或者引用 3）reinterpret_cast，大部分都能转，比如Int -> 指针   4）const_cast, 将const 转成非const

42. 野指针？

答：指向一个已经删除的对象或者未申请访问受限内存区域的指针

